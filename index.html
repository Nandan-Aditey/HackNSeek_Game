<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quark Invaders</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      font-family: monospace;
      color: lime;
    }
    canvas {
      display: block;
    }
    #message, #clicked {
      position: absolute;
      width: 100%;
      text-align: center;
      font-size: 1.5rem;
    }
    #message {
      top: 20px;
      display: none;
    }
    #clicked {
      top: 60px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="message">Keyword: <strong>udscbt</strong></div>
  <div id="clicked">Clicked: </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageDiv = document.getElementById('message');
    const clickedDiv = document.getElementById('clicked');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const quarkTypes = ['up', 'down', 'strange', 'charm', 'top', 'bottom'];
    const colors = {
      up: '#ff3',
      down: '#3ff',
      strange: '#f3f',
      charm: '#0f0',
      top: '#f00',
      bottom: '#00f'
    };

    const correctOrder = ['up', 'down', 'strange', 'charm', 'bottom', 'top'];
    let clickedSequence = [];

    class Quark {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.radius = 25;
        this.dx = Math.random() * 4 - 2;
        this.dy = Math.random() * 4 - 2;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = colors[this.type];
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.stroke();
        ctx.closePath();

        ctx.fillStyle = '#000';
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.type, this.x, this.y + 4);
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;

        if (this.x + this.radius > canvas.width || this.x - this.radius < 0) this.dx *= -1;
        if (this.y + this.radius > canvas.height || this.y - this.radius < 0) this.dy *= -1;

        this.draw();
      }

      isClicked(mx, my) {
        const dist = Math.hypot(this.x - mx, this.y - my);
        return dist < this.radius;
      }
    }

    const quarks = [];
    for (let i = 0; i < 15; i++) {
      const type = quarkTypes[Math.floor(Math.random() * quarkTypes.length)];
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      quarks.push(new Quark(x, y, type));
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      quarks.forEach(q => q.update());
      requestAnimationFrame(animate);
    }

    animate();

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      for (let q of quarks) {
        if (q.isClicked(mx, my)) {
          clickedSequence.push(q.type);
          clickedDiv.textContent = "Clicked: " + clickedSequence.join(' - ');

          if (clickedSequence.length === correctOrder.length) {
            if (clickedSequence.join(',') === correctOrder.join(',')) {
              revealMessage();
            } else {
              clickedDiv.textContent += " ❌ Wrong! Resetting...";
              setTimeout(() => {
                clickedSequence = [];
                clickedDiv.textContent = "Clicked: ";
              }, 1000);
            }
          }
          break;
        }
      }
    });

    function revealMessage() {
      messageDiv.style.display = 'block';
      clickedDiv.textContent += " ✅ Correct!";
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
